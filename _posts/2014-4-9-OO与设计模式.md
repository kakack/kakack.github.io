---

layout: post
categories: [Design Pattern]
tags: [Interview,Singleton,Design Pattern]

---

今天正式在IBM下的智慧物流开始了实习工作，由于另一边在准备CIIP和ECL Cloud Foundry，所以也会接触关于设计模式相关的内容。我吸取了之前去应聘面试没好好看人家requirement的教训，这次要有的放矢！！


- - -
##GoF的23个经典设计模式
关于设计模式，最经典的一个总结应该是[GoF的23个经典设计模式](http://www.cnblogs.com/springworks/p/3459458.html)。

![](https://raw.githubusercontent.com/kkkelsey/kkkelsey.github.io/master/_images/1404091.png)

其中的GoF是指“四人帮”，又称Gang of Four，即Erich Gamma, Richard Helm, Ralph Johnson & John Vlissides

其中简单的分类和描述可以这样理解：

```
【创建型】

Singleton（单例模式）：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 

Prototype（原型模式）：用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。 

Builder（建造者模式）：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 

Factory Method(工厂模式)：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。

Factory Method使一个类的实例化延迟到其子类。 Abstract Factory（抽象工厂模式）：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

```

```
【结构型】

Bridge（桥接模式）：将抽象部分与它的实现部分分离，使它们都可以独立地变化。 

Facade（外观模式）：为子系统中的一组接口提供一个一致的界面， Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 

Composite(组合模式)：将对象组合成树形结构以表示“部分-整体”的层次结构。它使得客户对单个对象和复合对象的使用具有一致性。 

Decorator(装饰模式)：动态地给一个对象添加一些额外的职责。就扩展功能而言， 它比生成子类方式更为灵活。 

Adapter（适配器模式）：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 

Proxy（代理模式）：为其他对象提供一个代理以控制对这个对象的访问。 

Flyweight（享元模式）：运用共享技术有效地支持大量细粒度的对象。

```

```
【行为型】

Iterator（迭代器模式）：提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。 

Interpreter（解析器模式）：给定一个语言, 定义它的文法的一种表示，并定义一个解释器, 该解释器使用该表示来解释语言中的句子。 

Observer（观察者模式）：定义对象间的一种一对多的依赖关系,以便当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并自动刷新。 

Mediator（中介者模式）：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 

Visitor（访问者模式）：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 

Memento（备忘录模式）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。 

State（状态模式）：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。 

Strategy（策略模式）：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。 

Template Method（模板方法模式）：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 

Command（命令模式）：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。 

Chain of Responsibility（职责链模式）：为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。 将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。
```

感谢作者的思维导图

![](https://raw.githubusercontent.com/kkkelsey/kkkelsey.github.io/master/_images/1404092.jpg)

- - -
##OO设计模式

OO面向对象的变成方法主要是为了实现三个目的：

- 可扩展性：有了新的需求，新的性能可以容易添加到系统中，不影响现有的性能，也不会带来新的缺陷。
- 可修改性：系统一部分的代码要修改时不会破坏系统的现有结构，也不会影响到其它的部分。
- 可替换性：可以将系统中的某些代码替换为相同接口的其它类，不会影响到系统。

其中几个设计原则

- 开放-封闭原则：对于扩展开放，对于修改关闭。关键在于抽象化，不允许修改的是抽象的类和接口，允许修改和扩展的是具体的实现类
- 封装变化点原则：封装可变因素，同时注意分块
- 里氏代换原则：可以用基类额地方，也可以用子类
- 依赖倒转原则：要依赖抽象,而不要依赖具体的实现。抽象不应当依赖于细节，细节应当依赖于抽象；要针对接口编程，不要针对实现编程
- 单一职责原则：一个类应该只有一个引起它变化的原因。
- 接口隔离法则：减小耦合性。
- 合成/聚合原则：在一个合成关系里，部分和整体的生命周期是一样的。合
- 迪米特法则：系统中的类,尽量不要与其他类互相作用，减少类之间的耦合度。


聚合(Aggregation)和合成(Composition)：
前者是一种非常松散的对象关系，而后者是一种非常强烈的对象相关关系。


```
	聚合：

     - 聚合有时能够不依赖部分而存在，有时又不能
     - 部分可以独立于聚合而存在
     - 如果有一部分遗失，聚合会给人一种不完全的感觉
     - 部分的所有权可以由几个聚合来共享，比如打印机

   合成：

     - 部分某一时刻只能属于某一个组成
     - 组成唯一的负责处理它的所有部分--这就意味着负责他们的创建与销毁
     - 倘若对于部分的职责由其他对象来承担的话，组成也就可以放松这些职责。
     - 如果组成销毁的话，它必须销毁所有的部分，或者把负责他们的权利转移给其他对象。
	
```

---
最后补一篇CoolShell上陈皓老师的[博客](http://coolshell.cn/articles/8961.html)，比较有趣地总结一下设计模式和OO“毛关系都没有”。