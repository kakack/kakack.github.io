---

layout: post
categories: [Apache]
tags: [Big Data, Hadoop, Distributed System, Apache Ambari]

---

#**设计目标**

###平台独立

系统支持所有硬件和操作系统，如RHEL、SLES、Ubuntu、Windows等，依赖于各个不同平台的所有组件（包括yum、rpm、debian等）也应当对于各个接口都能无缝衔接。

###组件插件化
整个架构必须不假设依赖于某个特定的工具或者技术。任何特定的工具或者技术都应该被封装成可插式的组件。整个架构关注相应的插件的可插性，并且让数据库来保持某些状态的稳定。

###版本管理和升级
Ambari的组件运行于多个节点，因此必须支持多种版本的协议来支持各个独立组件的升级。对于任何的组件来说，其升级都不会直接影响到整个集群本身。

###可扩展性
整个设计应当考虑到能够在之后轻松地添加新的服务、组件和API。可扩展性同样也要求对于Hadoop Stack中任何配置信息或者准备步骤都能做到能被简单地修改。同样，对于其他HDP的支持也要被考虑进去。

###容错
系统应该被设计成能队任何组件错误都能恢复到一个持久可靠状态的形式。同样，系统也应该在恢复完毕后，尝试着完成那些pending状态的操作。如果发生了那些未被定义的错误，那么不管是什么错误，整个系统依然需要被保持在一个固定如一的状态下。

###安全
整个安全系统要求：1，对于Ambari的用户进行授权和基于角色的权限管理（API和Web UI都符合）；2，通过Kerberos进行安装、管理，和对Hadoop Stack监控的安全控制；3，对于各个组件之间的交流也进行授权和加密。

###错误追踪
系统设计要求对错误追踪进行简单化处理，所有错误都应当将充分的细节和指针都通知到用户以作分析。

###操作保证能近乎实时并且有中间步骤回朔
对于那些需要一段时间完成的操作，系统需要能够向用户反馈当前的中间步骤、当前任务以及完成度百分比，这个过程可以引用log来完成。

- - -

#**术语**

###服务Service
泛指Hadoop Stack的服务。HDFS、HBase和Pig都是服务的例子。一个服务可能包含多个组件（HDFS有NameNode、DataNode和Secondary NameNode等多个组件）。一个服务也可以是一个客户端类库（Pig就没有任何daemon服务，只有一个客户端类库）。

###组件Component
一个服务可以由一个或者多个组件组成。举个例子，HDFS有三个组件：NameNode、DataNode和Secondary NameNode。组件也是可选的，一个组件也可以分布在多个节点上（如DataNode实例）。

###节点/宿主 Node/Host
节点是指集群上的一台机器。在文档中，节点和宿主也可以交换着使用。

###节点组件Node Component
节点组件是指在一个特定节点上的组件的实例，比如，一个特定节点上的特定DataNode实例是一个node-component。

###操作Operation
一个操作Operation是指一系列在集群上为满足用户要求或者达到某种状态改变而做的变更或者行为。举个例子，开启某个服务就是一个操作，运行一个Smoke test也是一个操作。

###任务Task
任务是指一个被送往节点去执行的最小单位的工作。一个任务是一个节点可以操作的最小行为单位。比如一个操作行为可以由在N1上安装一个datanode、在N2上安装一个secondary datanode两个任务。

###阶段Stage
一个阶段是指一个操作所需要的一组任务集合，它们之间相互独立，同一个阶段中所有的任务都可以并行地在不同节点上运行。

###行为Action
一个行为有一个或者多个任务组成，它们可以是在一台或者多台机器上运行。每个行为都可以被一个action id来追溯，而且节点会报告以行为为粒度的状态。一个行为可以由多个阶段组成来执行。

###阶段计划Stage Plan
一个操作通常由多个运行在多个机器上的任务组成，它们通常互相之间有一定的依赖关系，因此需要根据一定的顺序来完成。一些任务需要在别的任务能被安排前完成。因此，某个操作需要的这些任务可以被分割成多个阶段，其中某个阶段必须在其前置阶段完成之后才能被完成，然而同一个阶段的任务可以并行地被执行。

###任务单Manifest
任务单是指一个被发送到节点上执行的任务的定义。一个任务单必须完整地定义整个任务，而且需要被序列化。任务单同样也可以在硬盘上持久化来做记录或者恢复。

###角色Role
一个角色能映射到一个组件（NameNode、DataNode等）或者一个行为（HDFS重平衡、HBase Smoke test等）。

- - -

#**Ambari架构**

###High Level架构

![image](https://raw.githubusercontent.com/kkkelsey/kkkelsey.github.io/master/_images/1512301.png)

###Ambari Server

![image](https://raw.githubusercontent.com/kkkelsey/kkkelsey.github.io/master/_images/1512302.png)

###Ambari Agent

![image](https://raw.githubusercontent.com/kkkelsey/kkkelsey.github.io/master/_images/1512303.png)

- - -

#**用例**

###新增服务
在已有的集群上新增一个新服务，一般会遵循以下一些步骤：

- 请求通过API到达服务器，同时一个请求id会自动生成并附在请求上。这个请求的一个句柄handler被Coordinator调用。
- 这个API句柄在一个已有的节点上执行新增服务所需要的各个步骤。在此，这些步骤可以是：安装这个服务先决条件所要求的所有的组件，按照一定顺序启动先决条件所要求的组件，重新配置Nagios服务器将新服务的监控也一并加入
- Coordinator会在查询Dependency Tracker找到HBase中的先决条件。 Dependency Tracker会返回HDFS和ZooKeeper组件。 Coordinator也会查询Nagios server的依赖条件，会返回HBase client。Dependency Tracker也会返回所需组件的所需状态。因此，Coordinator会知道所有组件的集合和它们所需要的状态。Coordinator 会在DB中设定这些组件所需要的所有状态。
- 在之前的步骤中，Coordinator可以决定这需要用户的输入来为ZooKeeper选择节点来返回合适的结果。这取决于API语义。
- Coordinator之后会传递组件的序列和它们所需的状态到Stage Planner。Stage Planner会返回组件安装着的各个节点上需要执行的各个操作序列。 Stage Planner也会用Manifest Generator来生成一个Manifest。
- Coordinator会将有序的状态序列连同相应地请求id一并传递到Action Manager。
- Action Manager会更新每个node-component的状态，这可以反映出每个进行中的操作。
- Action Manager会为每个操作创建一个行为id并且将其加入到计划中。
- Heartbeat Handler会接收到各个行为的反馈，并且通知Action Manager。
- 每个行为结束都会被记录到数据库。
- Action Manager执行到下一个阶段并且重复。
###运行Smoke Test
集群上HDFS合HBase服务已经在运行，用户就可以运行Smoke Test。

- 请求通过API到达服务器，生成一个请求id，一个这个API的句柄被Coordinator调用。
- API Handler调用Dependency Tracker并且找到HBase服务必须运行来执行这个test。Dependency Tracker会暴露一个方法来告诉Coordinator宿主上哪个客户端组件是需要的。调用Stage Planner来为Smoke test生成一个计划。这个用例中，整个计划只有一个node-component上的一个阶段。
- 剩下的步骤与之前的类似。

###服务重配置
一个请求来保存配置信息到达服务器，新的配置快照被储存艹服务器上。这个请求同样包含了哪个服务、哪个宿主会被这些配置改变所影响。这表示了持久层需要追踪每个服务、组件、节点的基础信息，以及哪个是最后被更新的配置版本。 

###Ambari主服务器宕机和重启

###停用某些Datanode

- - -

#**代理**

代理每若干秒都会心跳一次传递给宿主服务器，并从那接收命令。心跳反馈是宿主服务器传递命令给代理唯一的办法。这个命令会被排列在行为队列中，这些命令会被行为执行器选取执行。因此这些心跳行为会在代理中异步执行。反馈信息也会被储存到消息队列中。

- - -

#**恢复**

这里用两种恢复的办法：

- 根据行为恢复：基于行为的持久化和重启，主节点会查看那些pending的行为并且重新安排它们。集群的状态也会在数据库中持久化，并且在重启的时候被重建。
- 根据所需状态回复： 基于状态的持久化和重启，根据当时现有的状态，主节点重启来满足所需要的状态，并尝试着重新储存集群的所需状态。

- - -

#**安全**
主要关注API的认证方法。

- 一种办法是使用HTTP基础认证。这种方法表示每个请求中客户端都会将证书传递给服务器，然后由服务器来验证证书的真实性，每个会话状态不必在服务器中保存。
- 另一种方法是利用HTTP会话和Cookies。一旦服务器认证了证书的真实性，服务器会生成和储存现在的会话id，这个会话id会被返回传递给客户端以cookie的形式储存。之后客户端的每次请求都会带上这个会话id，这种做法显然更加高效。 
- - -

#**Bootstrap**
在HMC (released as 1.0)中，bootstrapping是一个宿主上集成性很高的操作，包括安装和配置。在此不再详细展开。