---

layout: post
categories: [Big Data]
tags: [Big Data, Distributed System, Spark Streaming]

---

# 常用流数据工具调研与比较（上）

#### 关于流数据处理

对于数据处理最理想的情况是将所有待处理的数据都一次性放到内存或者其他数据处理工具的容器中，但是这种情况在真实操作过程中不太现实，因为容器一定是有大小限制的，但是当数据量远远超过这个大小时，就需要以流的形式，即实时收集的大量数据来做处理。


流数据处理特点：

- **计算强度**，是指每个I/O的算数操作的数量或者全局内存引用，在很多信号处理应用中，限现在这个值是超过50:1而且算法复杂度增长。

- **数据并行度**，存在一个内核中，如果相同的函数被应用到全部的输入流的记录中，并且一部分记录能在不需要等待前一部分记录的结果的情况下同时被处理。

- **数据局部性**是一种特殊类型的时间局域性，在信号和媒体处理过程中很常见，在这些处理过程中，数据通常被生产出来一次，之后在应用中被读取一到两次，之后再也不会被读到了。中间流在内核之间传递，就像是直接使用流数据模型中间数据，在此之中，内核函数能用流处理编程模型来直接捕捉到局部信息。

在数据流处理过程中，需要关注的几个问题有：查询策略如何？如何做数据抽样？如果做数据过滤？如何统计独立元素？等等。

关于查询：固定查询，对前来的数据一直在做查询和计算；即时查询，仅当一个查询操作提交的时候，才对数据进行查询。内存大小的限制，是数据流处理考虑的主要因素。因此，数据流处理算法的两个策略：1）用近似值代替精确解来换取性能上的优势; 2）hash技术，对求解近似解非常有帮助

关于抽样：以用户为单位进行抽样代替以记录为单位进行抽样，利用hash做桶处理，并对于某些特别大或者特别小的数值以阈值做标杆进行合并。

关于过滤：用Bloom过滤器，n位的数组，k个hash函数，m个待过滤的元素，假阳概率是(1 - e^(-km/n) )^k

- - - 

#### 关于工具

流计算使用的开源工具主要集中在Apache系列中，有Apache Storm、Spark Streaming和Apache Samza。另外常听到过的阿里Galaxy也会被涉及，但是因为是阿里内部工具，所以对它的了解只局限于一些阿里内部博客分享的范畴。对于Samza用的人少，了解的也不是很多。当前主要的对照比较就会集中在Streaming和Storm二者上。在这里也以这两大工具为主进行比较。

- - -

#### 关于阿里Galaxy

阿里的Galaxy承载着阿里巴巴内部几乎所有的流计算业务，但是其本身并不是一个简单的流计算框架，其被定义为一种“增量计算”的框架，即在当前计算过程中，结果不仅依赖于当前传入的批数据，也会受到先前传入的批数据影响，类似于迭代计算。NewResult = Function(CurrentBatch, OldBatch)。旧版本的Galaxy依赖于Storm，因为需要storm提供拓扑结构和worker调度等功能。与其他一些工具最大的不同在于Galaxy对于State的内部关联和处理。Galaxy的state暴露给计算task是线程级别独享的，在一批数据到达之后，进行merge计算过程中不会相互阻塞，颗粒度划分更细致。在计算层中，提供五种基础算子：map， reduce，merge，shuffle，union。因为缺乏详细文档，不再详细展开。

- - -

#### 关于Apache Samza

虽然在之前工作中使用过Apache Kafka，但是并没有配套使用与其关系最为紧密的Apache Samza。Kafka是一个分布式消息队列系统，已经实现很多底层的流式基础架构，一旦数据真正开始流动就自然形成一个Streaming。但是与一个真正的流处理框架相比，Kafka还缺少对于Producer/Consumer的进程管理、作业调度、容错、监控等功能，而Samza就补齐了这些功能，在消息系统上更高层的抽象。

Samza的处理过程以Kafka的job为主，在多个输入流中读取数据之后，输出到多个输出流，反映在Kafka中就是数据流从上层topic传递到下层topic，多个job串联之后就形成了流式数据的处理。

![](https://raw.githubusercontent.com/kakack/kakack.github.io/master/_images/20130927100812234.png)
 
而Samza的调度几乎完全依赖于Yarn，对于Yarn来说，在一整套的资源管理体系中，有以下一些核心组件：

- **ResourceManager**：以下简称RM。YARN的中控模块，负责统一规划资源的使用。

- **NodeManager**:以下简称NM。YARN的资源结点模块，负责启动管理container。

- **ApplicationMaster**:以下简称AM。YARN中每个应用都会启动一个AM，负责向RM申请资源，请求NM启动container，并告诉container做什么事情。

- **Container**：资源容器。YARN中所有的应用都是在container之上运行的。AM也是在container上运行的，不过AM的container是RM申请的。

![](https://raw.githubusercontent.com/kakack/kakack.github.io/master/_images/resource_manager-1024x759.png)

在资源的分配策略上，Yarn提供了三种不同的策略。FifoScheduler，CapacityScheduler和FairScheduler。

- **FIFOScheduler**：最简单，适用于只有一个队列的应用，符合先进先出规则，无优先级设置。
- **CapacityScheduler**：FIFOScheduler的多队列版本，每个队列可以限制资源用量，哥哥队列以树状结构组织，在队列的排序上以资源需求量最小的为优先。
- **FairScheduler**：多用户、多队列的进行分配，各个用户和队列之间设置权限，相对公平地按权限进行资源分配，有资源抢占机制，调度器按照资源公平算法计算出各个队列所需资源，释放掉超额部分容器。

在流式计算过程中，有个很重要的点是对于状态State的管理，在Kamza中用一个内建的per task数据库来储存历史信息，另外也向特定的topic写入message来做本地数据的log。

- - -

#### 总体比较Storm、Spark Streaming和Samza

因为之后会详细介绍Storm和Spark Streaming，所以先把比较部分提前。

总体来说，三者都为解决流数据处理，达到低延时、高容错、可扩展等目标，将任务并行分配到多个计算节点上进行运行。

在多个数据流的生命周期概念上，虽然各自命名不同，但都有异曲同工之处，

![](https://raw.githubusercontent.com/kakack/kakack.github.io/master/_images/wKiom1UGfxnwPgWbAAGKD5FiNog292.jpg)

而其不同之处，主要集中在以下四个点上。

![](https://raw.githubusercontent.com/kakack/kakack.github.io/master/_images/wKioL1UGgEqSJAKpAAKVu6KtldQ537.jpg)

在此又要提及对于流计算中最关键的状态管理，Spark Streaming将状态写入分布式文件系统如HDFS上，Samza如上文所述写入一个Key-Value的内建数据库中，而Storm中则将这部分工作滚动交给应用层来完成。

在用例上，三者也有一定区分：

- Storm，允许增量计算，希望实现高速、开箱即用，可以用任何编程语言来编写拓扑结构。
- Spark Streaming，不介意高延迟，但是提供有状态计算，恰好一次的传递，而且有较好需求扩展性，如图计算、机器学习、SQL访问等。
- Samza，待处理的状态量很大，由于将储存与处理放在同一个节点上，所以可以节省很多IO的开销。所以适用于处理量很大且来自于不同的来源的数据流。

- - -





