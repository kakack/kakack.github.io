---

layout: post
categories: [Java]
tags: [Java, JVM]

---

在Java中，常常有几个名词简称会被初学者弄混。

- **JRE**（Java Runtime Environment）： 运行JAVA程序所必须的环境的集合，包含JVM标准实现及Java核心类库。由Java API和JVM组成，通过Class Load来加载Java程序，并且使用Java API来执行加载的程序。
- **JAR**（Java Archive）：一种用来聚集多个Java Class文件，并且把metadata、resource关联到一个文件中，以便分发到应用或者类库到Java Platform
- **JDK**（Java Development Kit）：Sun公司出的关于Java的开发工具包(SDK，Software Development Kit)

- - - 

# 虚拟机Virtual Machine

虚拟机存在的意义在于，想在不同的操作系统、硬件环境中，用统一标准的环境，模拟出一定的物理机器环境，来满足Java的WORA（Write Once Run Anywhere）。

- 基于栈的虚拟机：Intel x86和ARM这两种最常见的计算机体系的机构都是基于寄存器的。不同的是，JVM是基于栈的。
- 符号引用：除了基本类型以外的数据（类和接口）都是通过符号来引用，而不是通过显式地使用内存地址来引用。
- 垃圾回收机制：类的实例都是通过用户代码进行创建，并且自动被垃圾回收机制进行回收。
- 通过对基本类型的清晰定义来保证平台独立性：传统的编程语言，例如C/C++，int类型的大小取决于不同的平台。JVM通过对基本类型的清晰定义来保证它的兼容性以及平台独立性。
- 网络字节码顺序：Java class文件用网络字节码顺序来进行存储:为了保证和小端的Intel x86架构以及大端的RISC系列的架构保持无关性，JVM使用用于网络传输的网络字节顺序，也就是大端。


- - -

# Java字节码Java Bytecode

JVM使用的Java字节码是介于Java和机器语言之间的中间语言。

JVM是模拟执行Java字节码的一个模拟器。Java编译器不会直接把高级语言（例如C/C++）编写的代码直接转换成机器语言（CPU指令）；它会把开发者可以理解的Java语言转换成JVM能够理解的Java字节码。因为Java字节码本身是平台无关的，所以它可以在任何安装了JVM（确切地说，是相匹配的JRE）的硬件上执行，即使是在CPU和OS都不相同的平台上（在Windows PC上开发和编译的字节码可以不做任何修改就直接运行在Linux机器上）。

---

# JVM结构

![](https://raw.githubusercontent.com/kakack/kakack.github.io/master/_images/1504141.jpg)

类装载器装载负责装载编译后的字节码，并加载到运行时数据区（Runtime Data Area），然后执行引擎执行会执行这些字节码。

具体的可以看下图：

![](https://raw.githubusercontent.com/kakack/kakack.github.io/master/_images/1504142.png)

总的来说应该分成四个层次结构：**类加载器、运行时数据区、执行引擎和方法接口**。

在内存空间中，**方法区域和堆**是所有Java线程共享的，而**Java栈、本地方法和PC寄存器**是私有的。


---

# 类加载器Class Loader

在Java中，提供的是动态装载，也就是说class不是在编译过程中装载的，而是在某个class第一次被引用的时候进行装载和连接的。这个动态装载工作就是由Class Loader来完成。

-  层级结构：Java里的类装载器被组织成了有父子关系的层级结构。Bootstrap类装载器是所有装载器的父亲。
- 代理模式：基于层级结构，类的装载可以在装载器之间进行代理。当装载器装载一个类时，首先会检查它是否在父装载器中进行装载了。如果上层的装载器已经装载了这个类，这个类会被直接使用。反之，类装载器会请求装载这个类。
- 可见性限制：一个子装载器可以查找父装载器中的类，但是一个父装载器不能查找子装载器里的类。
- 不允许卸载：类装载器可以装载一个类但是不可以卸载它，不过可以删除当前的类装载器，然后创建一个新的类装载器。

![](https://raw.githubusercontent.com/kakack/kakack.github.io/master/_images/1504143.jpg)

当一个类装载器（class loader）被请求装载类时，它首先按照顺序在上层装载器、父装载器以及自身的装载器的缓存里检查这个类是否已经存在。简单来说，就是在缓存里查看这个类是否已经被自己装载过了，如果没有的话，继续查找父类的缓存，直到在bootstrap类装载器里也没有找到的话，它就会自己在文件系统里去查找并且加载这个类。

- **启动类加载器（Bootstrap class loader）**:这个类装载器是在JVM启动的时候创建的。它负责装载rt.jar中所有类，即Java核心类——Java API，包含Object对象。和其他的类装载器不同的地方在于这个装载器是通过native code（在Sun JDK中，这部分是C++写的，不能在Java中获得引用）来实现的，而不是用Java代码。
- **扩展类加载器（Extension class loader）**:它装载除了基本的Java API以外的扩展类。它也负责装载其他的安全扩展功能。
- **系统类加载器（System class loader）**:如果说bootstrap class loader和extension class loader负责加载的是JVM的组件，那么system class loader负责加载的是应用程序类。它负责加载用户在$CLASSPATH里指定的类。
- **用户自定义类加载器（User-defined class loader）**:这是应用程序开发者用直接用代码实现的类装载器。


如果类装载器查找到一个没有装载的类，它会按照下图的流程来装载和链接这个类:

![](https://raw.githubusercontent.com/kakack/kakack.github.io/master/_images/1504144.jpg)

总的来说，Class Loader进行类加载的时候分为三步：**装载、链接、初始化**

- **Loading**: 类的信息从文件中获取并且载入到JVM的内存里。在内存中，Class Loader的实例和类的实例都会被存放于堆中，它们的类信息被存放在方法区中。装载过程采用了一种被称为***“双亲委派模型（Parent Delegation Model）”***的方式，当一个ClassLoader要加载类时，它会先请求它的双亲ClassLoader（其实这里只有两个ClassLoader，所以称为父ClassLoader可能更容易理解）加载类，而它的双亲ClassLoader会继续把加载请求提交再上一级的ClassLoader，直到启动类加载器。只有其双亲ClassLoader无法加载指定的类时，它才会自己加载类。双亲委派模型是JVM的第一道安全防线，它保证了类的安全加载，这里同时依赖了类加载器隔离的原理：不同类加载器加载的类之间是无法直接交互的，即使是同一个类，被不同的ClassLoader加载，它们也无法感知到彼此的存在。这样即使有恶意的类冒充自己在核心包（例如java.lang）下，由于它无法被启动类加载器加载，也造成不了危害。由此也可见，如果用户自定义了类加载器，那就必须自己保障类加载过程中的安全。
- **Linking**：链接的任务是把二进制的类型信息合并到JVM运行时状态中去。
  
	- **Verifying**:检查读入的结构是否符合Java语言规范以及JVM规范的描述。这是类装载中最复杂的过程，并且花费的时间也是最长的。并且JVM TCK工具的大部分场景的用例也用来测试在装载错误的类的时候是否会出现错误。
	- **Preparing**:分配一个结构用来存储类信息，这个结构中包含了类中定义的成员变量，方法和接口的信息。初始化类中的静态变量赋值为默认值。
	- **Resolving**:把这个类的常量池中的所有的符号引用改变成直接引用。
	
- **Initializing**:把类中的变量初始化成合适的值。执行静态初始化程序，把静态变量初始化成指定的值。JVM严格

附：JVM严格规范了何时需要对类进行初始化：
  
  >1  通过new关键字、反射、clone、反序列化机制实例化对象时。
  
  >2  调用类的静态方法时。
  
  >3  使用类的静态字段或对其赋值时
  
  >4  通过反射调用类的方法时
  
  >5  初始化该类的子类时（子类初始化前其父类必须依据被初始化）
  
  >6  JVM启动时候被标记为启动类的类（简单理解为具有main方法的类）


---

# 运行时数据区

![](https://raw.githubusercontent.com/kakack/kakack.github.io/master/_images/1504145.jpg)

运行时数据区是在JVM运行的时候操作所分配的内存区。运行时内存区可以划分为6个区域。在这6个区域中，一个PC Register, JVM stack 以及Native Method Statck都是按照线程创建的，Heap,Method Area以及Runtime Constant Pool都是被所有线程公用的。

- **PC寄存器(PC register)**:每个线程启动的时候，都会创建一个PC(Program Counter ,程序计数器)寄存器。PC寄存器里保存有当前正在执行的JVM指令的地址。
- **JVM 堆栈(JVM stack)**：每个线程启动的时候，都会创建一个JVM堆栈。它是用来保存栈帧的。JVM只会在JVM堆栈上对栈帧进行push和pop的操作。如果出现了异常，堆栈跟踪信息的每一行都代表一个栈帧立的信息，这些信息它是通过类似于printStackTrace()这样的方法来展示的。
- **栈帧(stack frame)**：每当一个方法在JVM上执行的时候，都会创建一个栈帧，并且会添加到当前线程的JVM堆栈上。当这个方法执行结束的时候，这个栈帧就会被移除。每个栈帧里都包含有当前正在执行的方法所属类的本地变量数组，操作数栈，以及运行时常量池的引用。本地变量数组的和操作数栈的大小都是在编译时确定的。因此，一个方法的栈帧的大小也是固定不变的。
- **局部变量数组(Local variable array)**：这个数组的索引从0开始。索引为0的变量表示这个方法所属的类的实例。从1开始，首先存放的是传给该方法的参数，在参数后面保存的是方法的局部变量。
- **操作数栈(Operand stack)**：方法实际运行的工作空间。每个方法都在操作数栈和局部变量数组之间交换数据，并且压入或者弹出其他方法返回的结果。操作数栈所需的最大空间是在编译期确定的。因此，操作数栈的大小也可以在编译期间确定。
- **本地方法栈(Native method stack)**：供用非Java语言实现的本地方法的堆栈。换句话说，它是用来调用通过JNI(Java Native Interface Java本地接口）调用的C/C++代码。根据具体的语言，一个C堆栈或者C++堆栈会被创建。
- **方法区(Method area)**：方法区是所有线程共享的，它是在JVM启动的时候创建的。它保存所有被JVM加载的类和接口的运行时常量池，成员变量以及方法的信息，静态变量以及方法的字节码。JVM的提供者可以通过不同的方式来实现方法区。在Oracle 的HotSpot JVM里，方法区被称为永久区或者永久代（PermGen）。是否对方法区进行垃圾回收对JVM的实现是可选的。
- **运行时常量池(Runtime constant pool)**：这个区域和class文件里的constant_pool是相对应的。这个区域是包含在方法区里的，不过，对于JVM的操作而言，它是一个核心的角色。因此在JVM规范里特别提到了它的重要性。除了包含每个类和接口的常量，它也包含了所有方法和变量的引用。简而言之，当一个方法或者变量被引用时，JVM通过运行时常量区来查找方法或者变量在内存里的实际地址。
- **堆(Heap)**：用来保存实例或者对象的空间，而且它是垃圾回收的主要目标。当讨论类似于JVM性能之类的问题时，它经常会被提及。JVM提供者可以决定怎么来配置堆空间，以及不对它进行垃圾回收。

---

# 执行引擎（Execution Engine）

通过类装载器装载的，被分配到JVM的运行时数据区的字节码会被执行引擎执行。执行引擎以指令为单位读取Java字节码。它就像一个CPU一样，一条一条地执行机器指令。每个字节码指令都由一个1字节的操作码和附加的操作数组成。执行引擎取得一个操作码，然后根据操作数来执行任务，完成后就继续执行下一条操作码。

为了把Java这种高级语言转化为机器(JVM)可以阅读的语言，字节码通过下面两种方式转换：

- **解释器**：一条一条地读取，解释并且执行字节码指令。因为它一条一条地解释和执行指令，所以它可以很快地解释字节码，但是执行起来会比较慢。这是解释执行的语言的一个缺点。字节码这种“语言”基本来说是解释执行的。
- **即时(Just-In-Time)编译器**：即时编译器被引入用来弥补解释器的缺点。执行引擎首先按照解释执行的方式来执行，然后在合适的时候，即时编译器把整段字节码编译成本地代码。然后，执行引擎就没有必要再去解释执行方法了，它可以直接通过本地代码去执行它。执行本地代码比一条一条进行解释执行的速度快很多。编译后的代码可以执行的很快，因为本地代码是保存在缓存里的。

不过，用JIT编译器来编译代码所花的时间要比用解释器去一条条解释执行花的时间要多。因此，如果代码只被执行一次的话，那么最好还是解释执行而不是编译后再执行。因此，内置了JIT编译器的JVM都会检查方法的执行频率，如果一个方法的执行频率超过一个特定的值的话，那么这个方法就会被编译成本地代码。

![](https://raw.githubusercontent.com/kakack/kakack.github.io/master/_images/1504146.jpg)

大部分的JIT编译器都是按照下图的方式来执行的：

![](https://raw.githubusercontent.com/kakack/kakack.github.io/master/_images/1504147.jpg)

JIT编译器把字节码转换成一个中间层表达式，一种中间层的表示方式，来进行优化，然后再把这种表示转换成本地代码。

整个执行过程被分为四个步骤：**解释执行、编译执行、自适应优化执行、硬件芯片执行**

- 解释执行：JVM动态执行字节码。有以下几种优化方式
	- 栈定缓存：将位于操作数栈顶的值直接缓存在寄存器上，对于大部分只需要一个操作数的指令而言，就无需再入栈，可以直接在寄存器上进行计算，结果压入操作数站。这样便减少了寄存器和内存的交换开销。
	- 部分栈帧共享：被调用方法可将调用方法栈帧中的操作数栈作为自己的局部变量区，这样在获取方法参数时减少了复制参数的开销。
	- 执行机器指令
- 编译执行：即上文解释的JIT编译器
- 自适性优化执行：自适应优化执行的思想是程序中10%~20%的代码占据了80%~90%的执行时间，所以通过将那少部分代码编译为优化过的机器码就可以大大提升执行效率。自适应优化的典型代表是Sun的Hotspot VM，正如其名，JVM会监测代码的执行情况，当判断特定方法是瓶颈或热点时，将会启动一个后台线程，把该方法的字节码编译为极度优化的、静态链接的C++代码。当方法不再是热区时，则会取消编译过的代码，重新进行解释执行。



