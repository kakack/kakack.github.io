---

layout: post
categories: [Interview]
tags: [Algorithm,Database]

---

#B-Tree & B+Tree in Data Searching and Database Index


因为上班时候要用到一些B+Tree的内容，所以就把好久没看的这部分拿出来再回顾总结一下


- - -

##B-Tree

B- 树是一种平衡的多路查找树，用于外查找，在文件系统中用到多。概念和定义如下：

对于一棵m阶的B-Tree来说，有以下一些特征：

	- 所有node最多有m个child node
	- 除了root和leaves外，其它每个结点至少有m/2个孩子；
	- 若根结点不是叶子结点，则至少有2个孩子；
	- 所有叶子结点(失败节点)都出现在同一层，叶子结点不包含任何关键字信息；
    - 所有非终端结点中包含下列信息数据 ( n, A0 , K1 , A1 , K2 , A2 , … , Kn , An )，其中： Ki (i=1,…,n)为关键字，且Ki < Ki+1 , Ai (i=0,…,n)为指向子树根结点的指针, n为关键字的个数
	- 非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；

最后所有leaves node都在同一个深度，也就是树的高度，如一个4阶 B-Tree，深度为4

![](http://my.csdn.net/uploads/201207/28/1343441845_4081.jpg)

###查找算法

类似于二叉树，不同的是在B-tree中，查找一个关键字的时候，先在有序表中查询，如果没有找到，再根据对应的指针到相应的子树中查找，如果在leaves的有序表中还没找到表示树中没有这个值。

```
typedef int KeyType ;  
#define m 5                 /*B 树的阶，暂设为5*/  
typedef struct Node{  
    int keynum;             /* 结点中关键码的个数，即结点的大小*/  
    struct Node *parent;    /*指向双亲结点*/   
    KeyType key[m+1];       /*关键码向量，0 号单元未用*/   
    struct Node *ptr[m+1];  /*子树指针向量*/   
    Record *recptr[m+1];    /*记录指针向量*/  
}NodeType;                  /*B 树结点类型*/  
  
typedef struct{  
    NodeType *pt;           /*指向找到的结点*/  
    int i;                  /*在结点中的关键码序号，结点序号区间[1…m]*/  
    int tag;                /* 1:查找成功，0:查找失败*/  
}Result;                    /*B 树的查找结果类型*/  
  
Result SearchBTree(NodeType *t,KeyType kx)  
{   
    /*在m 阶B 树t 上查找关键码kx，反回(pt,i,tag)。若查找成功，则特征值tag=1，*/  
    /*指针pt 所指结点中第i 个关键码等于kx；否则，特征值tag=0,等于kx 的关键码记录*/  
    /*应插入在指针pt 所指结点中第i 个和第i+1 个关键码之间*/  
    p=t;q=NULL;found=FALSE;i=0; /*初始化，p 指向待查结点，q 指向p 的双亲*/  
    while(p&&!found)  
    {   n=p->keynum;i=Search(p,kx);          /*在p-->key[1…keynum]中查找*/  
        if(i>0&&p->key[i]= =kx) found=TRUE; /*找到*/  
        else {q=p;p=p->ptr[i];}  
    }  
    if(found) return (p,i,1);               /*查找成功*/  
    else return (q,i,0);                    /*查找不成功，反回kx 的插入位置信息*/  
}  

```

在查找算法中，可以分为两个步骤

	1. 在B-Tree中查找节点
	2. 在节点中查找关键字

而在磁盘上查找的次数，也就是待查找关键字所在节点在B-Tree上的深度，是决定查找效率的关键要素，由其特征，我们假设一个m阶的B-Tree包含n个关键字，因此假设有n+1个leaves在第k+1层：

1. 第一层为root，至少一个节点，至少2个child node，因此至少第二层还有2个node
2. 除了根和树叶外，其它结点至少有[m/2]个孩子,因此第三层至少有2*[m/2]个结点,在第四层至少有2*[m/2]^2 个结点…以此类推
3. 于是我们得到在k+1层至少有2*[m/2]^(k+1)，得到

![](http://my.csdn.net/uploads/201208/05/1344136805_2674.jpg)
	也就是在n个关键字的m阶B-Tree中查找，从根节点到叶节点所涉及的节点的上限
	

###插入和删除算法
在B-Tree中插入一个关键字，首先在最底层叶节点增加一个关键字，若该节点关键字个数超过m-1个，则产生节点的分裂。效果可以在[可视化B-Tree中自行观看](https://www.cs.usfca.edu/~galles/visualization/BTree.html)

```
int InserBTree(NodeType **t,KeyType kx,NodeType *q,int i){   
    /* 在m 阶B 树*t 上结点*q 的key[i],key[i+1]之间插入关键码kx*/   
    /*若引起结点过大，则沿双亲链进行必要的结点分裂调整，使*t仍为m 阶B 树*/  
    x=kx;ap=NULL;finished=FALSE;  
    while(q&&!finished)  
    {   
        Insert(q,i,x,ap);               /*将x 和ap 分别插入到q->key[i+1]和q->ptr[i+1]*/  
        if(q->keynum<m) finished=TRUE;    /*插入完成*/  
        else  
        {                               /*分裂结点*p*/  
            s=m/2;split(q,ap);x=q->key[s];  
            /*将q->key[s+1…m],q->ptr[s…m]和q->recptr[s+1…m]移入新结点*ap*/  
            q=q->parent;  
            if(q) i=Search(q,kx); /*在双亲结点*q 中查找kx 的插入位置*/  
        }  
    }  
    if(!finished)           /*(*t)是空树或根结点已分裂为*q*和ap*/  
    NewRoot(t,q,x,ap); /*生成含信息(t,x,ap)的新的根结点*t,原*t 和ap 为子树指针*/  
}  

```

##B+Tree 

B+Tree是B-Tree的一种变形，两棵同位m阶的B+Tree和B-Tree之间的区别在于：
	
	1. 有n 棵子树的结点中含有n 个关键码；
	2. 所有的叶子结点中包含了全部关键码的信息，及指向含有这些关键码记录的指针，且叶子结点本身依关键码的大小自小而大的顺序链接。
	3. 所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键码。

如这是一棵3阶的B+Tree：

![](http://my.csdn.net/uploads/201207/28/1343448307_6771.jpg)

通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点。因此可以对B+Tree进行两种查找运算：一种是从最小关键字起顺序查找，另一种是从根节点开始，进行随机查找。

B+Tree的随机查找、插入、删除过程与B-Tree基本一致，只是在查找时，若非终端结点上的关键码等于给定值，并不终止，而是继续向下直到叶子结点。因此，在B+Tree，不管查找成功与否，每次查找都是走了一条从根到叶子结点的路径。

可以在[B+Tree Visualization](https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html)中查看


##数据库中的应用


####索引
索引是对数据库表 中一个或多个列的值进行排序的结构。与在表 中搜索所有的行相比，索引用指针 指向存储在表中指定列的数据值，然后根据指定的次序排列这些指针，有助于更快地获取信息。通常情 况下 ，只有当经常查询索引列中的数据时 ，才需要在表上创建索引。索引将占用磁盘空间，并且影响数 据更新的速度。但是在多数情况下 ，索引所带来的数据检索速度优势大大超过它的不足之处。


####B+Tree在索引中
B-Tree和B+Tree是目前数据库系统和文件系统中常用的索引结构

- 叶结点的组织方式 。B+树的查找键 是数据文件的主键 ，且索引是稠密的。也就是说 ，叶结点 中为数据文件的第一个记录设有一个键、指针对 ，该数据文件可以按主键排序，也可以不按主键排序 ；数据文件按主键排序，且 B +树是稀疏索引 ，  在叶结点中为数据文件的每一个块设有一个键、指针对 ；数据文件不按键属性排序 ，且该属性是 B +树 的查找键 ， 叶结点中为数据文件里出现的每个属性K设有一个键 、 指针对 ， 其中指针执行排序键值为 K的 记录中的第一个。

- 非叶结点 的组织方式。B+树 中的非叶结点形成 了叶结点上的一个多级稀疏索引。每个非叶结点中至少有ceil(m/2) 个指针，至多有m个指针。

二叉查找树进化品种的红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-/+Tree作为索引结构。

　一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。为什么使用B-/+Tree，还跟磁盘存取原理有关。


- - -
##附录特性
对于一个b阶，高度为h的B+Tree而言：

- 能存的最大记录数是：因为每个节点最多不能超过m-1个child nodes，所以如果只有一层，那么是b-1个记录，如果2层，那么root就可以有b个child nodes，所以最多有b(b-1)个，以此类推，如果有h层，那么就有(b-1)b^(h-1)个记录，即![](http://upload.wikimedia.org/math/0/0/4/00496c49966ec12738a7d81cb21f0513.png)
- 能存得最小记录数是：因为根节点至少有2个child nodes，所以如果有1层那至少有2个记录，如果2层那第二层每个至少[b/2]个child nodes，所以最少2*[b/2]，以此类推，h层最少为![](http://upload.wikimedia.org/math/9/3/2/932ee663ccc50f8df3af31d45af73626.png)
- 储存的空间复杂度是：O(n)
- 插入，删除和查询操作需要：![](http://upload.wikimedia.org/math/8/c/0/8c0073eeb8b26520b553eda1a558a986.png)

- - -
##例子

















