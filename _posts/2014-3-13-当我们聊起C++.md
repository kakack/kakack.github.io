---

layout: post
categories: [C++]
tags: [C++]

---

紧张地被通知百度明天下午4：00打电话来面，搜了一下面经吓得屁滚尿流，要不要这样啊亲！还要自备电脑当场写code给他看，于是之前看了Java，今天就看看C++相关的内容。当我们和面试官聊起C++，可能会说些这样的话题
- - -

### static

Static是C++中用来控制变量储存方式和可见性的关键字。当我们使用static时是需要一个数据对象为整个类而非某个对象服务,同时又力求不破坏类的封装性,即要求此成员隐藏在类的内部，对外不可见。没有this指针，不能包含虚函数做成员函数，

静态成员使用方法：<类名>::<静态成员名>，静态成员是属于整个类的而不是某个对象，静态成员变量只存储一份供所有对象共用。所以在所有对象中都可以共享它。使用静态成员变量实现多个对象之间的数据共享不会破坏隐藏的原则，保证了安全性还可以节省内存。静态成员函数中不能引用非静态成员。

### this指针

this 指针是一个隐含于每一个类的成员函数中的特殊指针（包括析构函数和构造函数），它用于指向正在被成员函数操作的对象。不是对象的一部分，不影响sizeof()。

### const

const关键字修饰的内容不可被改变，被const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。

1. 修饰变量，表示类型为Type的变量value是不可变的：

      TYPE const ValueName = value; 
        
      const TYPE ValueName = value; 
2. 修饰指针：
    - 指针是常量： 
    
         char *const cp; //到char的const指针
 
    - 指针指向的内容是常量：
         
         char const *pc1; //到const char的指针
         
         const char *pc2; //到const char的指针（这两个声明是等同的）
    
    - 两者都不可变
    
         const char* const pContent;
     
3. 函数中使用：
    - const修饰函数参数
    - const修饰函数返回值
4. 类相关：
    - const修饰成员变量，表示成员常量，不能被修改，同时它只能在初始化列表中赋值。
    - const修饰类的成员函数，则该成员函数不能修改类中任何非const成员函数。一般写在函数的最后来修饰。
    - const修饰类对象/对象指针/对象引用，const对象只能访问const的成员函数
    

### Reference

引用是某一个目标变量的别名，不占用储存单元，但是要在一开始初始化。作为函数参数时和指针效果一样。

和指针的关系：引用是对象的别名，操作引用就是操作这个对象，必须在创建的同时有效得初始化（引用一个有效的对象，不可为NULL），初始化完毕就再也不可改变，引用具有指针的效率，又具有变量使用的方便性和直观性，在语言层面上引用和对象的用法一样，在二进制层面上引用一般都是通过指针来实现的，只是编译器帮我们完成了转换。之所以使用引用是为了用适当的工具做恰如其分的事，体现了最小特权原则。


### 内存分配

1）从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在，如全局变量，static变量。

2）在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

3）从堆上分配（动态内存分配）程序在运行的时候用malloc或new申请任意多少的内存，程序员负责在何时用free或delete释放内存。动态内存的生存期自己决定，使用非常灵活。

 new/delete与malloc()/free()：都是在堆(heap)上进行动态的内存操作。用malloc函数需要指定内存分配的字节数并且不能初始化对象，new 会自动调用对象的构造函数。delete 会调用对象的destructor，而free 不会调用对象的destructor.
    
- 操作对象：前者是C++的运算符，后者是C++的标准库函数，对于非内部数据类的对象而言，光用malloc或free无法满足要求，不在编译器控制范围内，所以不能把构造函数和析构函数强加给malloc/free，因此C++需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。
- 用法上：1、malloc的原型是void * malloc(size_t size); 返回值的类型是void *，所以在调用malloc 时要显式地进行类型转换，将void * 转换成所需要的指针类型。2、 malloc 函数本身并不识别要申请的内存是什么类型，它只关心内存的总字节数。
    
在C++中，内存可以分为以下五个块：

 - 栈区stack：由编译器自动分配和释放，存放函数的参数值、局部变量的值
 - 堆区heap：由程序员分配和释放，如果不释放则会在程序结束时由操作系统收回，分配类型类似于链表
 - 全局区（静态区）static：全局变量和静态变量是存放在一起的，初始化的全局变量和静态变量在一块，未初始化的在相邻的另一块区域，程序结束后由系统释放
 - 文字常量区：存常量字符串，程序结束后系统释放
 - 程序代码区：存放函数体的二进制代码
 

 
    