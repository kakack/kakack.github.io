---

layout: post
categories: [Interview]
tags: [Interview,C++,Algorithm,STL]

---

本文总结一下关于C++ STL的一些内容，尤其是其中容器的部分

STL是Standard Template Library，标准模板库，包括container容器、algorithm算法和iterator迭代器。

---
##基础
1. 泛型。可以用多态、模板来实现。模板是编译时候决定的，而多态是运行时决定的。多态是依靠虚表在运行时查表实现的。泛型设计的根本思想就是想把算法和其作用的数据结构分离，也就是说，我们设计算法的时候并不去考虑我们设计的算法将作用于何种数据结构之上。泛型设计的理想状态是一个查找算法将可以作用于数组，联表，树，图等各种数据结构之上，变成一个通用的，泛型的算法。
2. 四种类型转换操作符。***static_cast***以符合逻辑的方式转型，可以父子类互相转。***dynamic_cast *** 将多态类型向下转换为其实际静态类型。只能用于对象的指针和引用。***reinterpret_cast***  转换一个指针为其它类型的指针。它也允许从一个指针转换为整数类型。反之亦然。这个操作符能够在非相关的类型之间转换。***const_cast***一般用于强制消除对象的常量性。
3. explicit修饰的构造函数不能担任转换函数。在很多情况下，隐式转换是有意的，并且是正当的。但有时我们不希望进行这种自动的转换。
4. 命名空间namespace解决在使用不同模块和程序库时，出现名称冲突问题。
5. C++标准程序库中的通用工具。由类和函数构成。这些工具包括：数种通用类型；一些重要的C函数；数值极值

---
##六大组件

####1、容器

***前三个是顺序容器***

- 向量vector 【vector】：可以用常数时间访问和修改任意元素，在序列尾部进行插入和删除时，具有常数时间复杂度，对任意项的插入和删除就有的时间复杂度与到末尾的距离成正比，尤其对向量头的添加和删除的代价是惊人的高的

   底层的数据为数组，支持快速随机方位。其所为的连续增长是一个假象，因为存储空间是连续的，所以其实是申请新的空间，复制过去，然后释放原有空间。

- 双端队列deque【deque】：基本上与向量相同，唯一的不同是，其在序列头部插入和删除操作也具有常量时间复杂度

   底层的数据结构采用的是一块所谓的map（不同于STL中的map）作为主控，其中每个元素都是指针，指向另一块较大的连续空间，称为缓冲区。


- 表list【list】：对任意元素的访问与对两端的距离成正比，但对某个位置上插入和删除一个项的花费为常数时间。

   底层数据结构是一个双向环状链表。
   
   ```
   选择原则
   1) 如果你需要高效的随即存取，而不在乎插入和删除的效率，使用vector
   2) 如果你需要大量的插入和删除，而不关心随即存取，则应使用list
   3) 如果你需要随即存取，而且关心两端数据的插入和删除，则应使用deque
   ```

***以下两个属于容器适配器***底层都是封装了deque，不用vector是因为deque删除元素时释放空间，而申请新空间时不必拷贝所有的元素

- 队列queue【queue】：
插入只可以在尾部进行，删除、检索和修改只允许从头部进行。按照先进先出的原则。

- 堆栈stack【stack】：堆栈是项的有限序列，并满足序列中被删除、检索和修改的项只能是最近插入序列的项。即按照后进先出的原则

***以下属于关联容器***底层都是用了Balance Tree/Black-Red Tree来实现

- 集合set【set】：由节点组成的红黑树，每个节点都包含着一个元素，节点之间以某种作用于元素对的谓词排列（可以理解为元素的升序排序），没有两个不同的元素能够拥有相同的次序，具有快速查找的功能。但是它是以牺牲插入删除操作的效率为代价的

- 多重集合multiset【set】:和集合基本相同，但可以支持重复元素具有快速查找能力

- 映射map【map】:由{键，值}对组成的集合，以某种作用于键对上的谓词排列。底层是balance tree，具有快速查找能力

- 多重集合multimap【map】:比起映射，一个键可以对应多了值。具有快速查找能力

![](https://raw.githubusercontent.com/kkkelsey/kkkelsey.github.io/master/_images/140413.JPG)


####2、算法
略

####3、迭代器
指针可以理解为迭代器的一种特例。

- 输入迭代器Input iterator:向前读Reads forward,istream
- 输出迭代器Output iterator:向前写Writes forward,ostream,inserter
- 前向迭代器Forward iterator:向前读写,Read and Writes forward
- 双向迭代器Bidirectional iterator:向前向后读写Read and Writes forward and
backward,list,set,multiset,map,mul timap
- 随机迭代器:Random access iterator:随机读写Read and Write with random
access,vector,deque,array,string


####4、仿函数
仿函数，又或叫做函数对象，是STL六大组件之一；仿函数虽然小，但却极大的拓展了算法的功能，几乎所有的算法都有仿函数版本。例如，查找算法find_if就是对find算法的扩展，标准的查找是两个元素相等就找到了，但是什么是相等在不同情况下却需要不同的定义，如地址相等，地址和邮编都相等，虽然这些相等的定义在变，但算法本身却不需要改变，这都多亏了仿函数。仿函数(functor)又称之为函数对象（function object），其实就是重载了()操作符的struct，没有什么特别的地方。

特点：

1).仿函数比一般的函数灵活。

2).仿函数有类型识别，可以作为模板参数。

3).执行速度上仿函数比函数和指针要更快的。

####5、适配器
适配器是用来修改其他组件接口的STL组件，是带有一个参数的类模板（这个参数是操作的值的数据类型）。STL定义了3种形式的适配器：容器适配器，迭代器适配器，函数适配器。

- 容器适配器：包括栈（stack）、队列(queue)、优先(priority_queue)。使用容器适配器，stack就可以被实现为基本容器类型（vector,dequeue,list）的适配。可以把stack看作是某种特殊的vctor,deque或者list容器，只是其操作仍然受到stack本身属性的限制。queue和priority_queue与之类似。容器适配器的接口更为简单，只是受限比一般容器要多。
- 迭代器适配器：修改为某些基本容器定义的迭代器的接口的一种STL组件。反向迭代器和插入迭代器都属于迭代器适配器，迭代器适配器扩展了迭代器的功能。
- 函数适配器：通过转换或者修改其他函数对象使其功能得到扩展。这一类适配器有否定器（相当于"非"操作）、绑定器、函数指针适配器。函数对象适配器的作用就是使函数转化为函数对象，或是将多参数的函数对象转化为少参数的函数对象。


####6、空间适配器
STL的内存配置器在我们的实际应用中几乎不用涉及，但它却在STL的各种容器背后默默做了大量的工作，STL内存配置器为容器分配并管理内存。统一的内存管理使得STL库的可用性、可移植行、以及效率都有了很大的提升。
SGI-STL的空间配置器有2种，一种仅仅对c语言的malloc和free进行了简单的封装，而另一个设计到小块内存的管理等，运用了内存池技术等。在SGI-STL中默认的空间配置器是第二级的配置器。


---
我比较关心的是容器那一块，关于各个容器具体的函数操作和算法就不多写了